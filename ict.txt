ictê¸°ë²•vs ì¶”ì„¸ì¶”ì¢…ë§¤ë§¤ ì–´ëŠê²ƒì´ ìë™ë§¤ë§¤ë´‡ì— ë” ì¢‹ì„ì§€ í† ë¡ í•´ë³´ì. ë§¤ì¼ 1%ì˜ ìˆ˜ìµë¥ ì„ ì–»ê¸° ìœ„í•œ ëŒ€ ì—¬ì • í”„ë¡œê·¸ë¨ ê°œë°œì„ í•˜ê³ ì‹¶ì–´.
í¥ë¯¸ë¡œìš´ í† ë¡ ì…ë‹ˆë‹¤. "ë§¤ì¼ 1% ìˆ˜ìµë¥  ìë™í™”"ë¼ëŠ” ëª…í™•í•œ ëª©í‘œ í•˜ì—ì„œ ICT vs ì¶”ì„¸ì¶”ì¢…ì„ ì‹¬ì¸µ ë¹„êµí•˜ê³ , ìµœì ì˜ "í•˜ì´ë¸Œë¦¬ë“œ ì „ëµ"ì„ ì œì•ˆí•˜ê² ìŠµë‹ˆë‹¤.

ğŸ¯ í•µì‹¬ ë¹„êµ: ICT vs ì¶”ì„¸ì¶”ì¢… (Trend Following)
1ï¸âƒ£ ì „ëµ ì² í•™ ë¹„êµ
í•­ëª©	ICT (Smart Money)	ì¶”ì„¸ì¶”ì¢… (Trend Following)
í•µì‹¬ ì•„ì´ë””ì–´	"ê¸°ê´€ì˜ ì†ì ˆê°€ ê°™ì€ ìë¦¬ë¥¼ ì½ê³  ê±°ê¸°ì„œ ë°˜ë“±"	"ê°€ê²©ì´ ì´ë¯¸ ì˜¬ë¼ê°€ëŠ” ë°©í–¥ìœ¼ë¡œ ë”°ë¼ê°€ê¸°"
ì§„ì… íƒ€ì´ë°	ì•½ì„¸ (ì €ê°€ êµ¬ê°„ì—ì„œ)	ê°•ì„¸ (ìƒìŠ¹ì„¸ê°€ í™•ì‹¤í•  ë•Œ)
ìˆ˜ìµ êµ¬ì¡°	ì €ê°€ ì§„ì… â†’ ì¤‘ê°€ ë§¤ë„ (ì°¨ì´ ë¨¹ê¸°)	ì¤‘ê°€ ì§„ì… â†’ ê³ ê°€ ë§¤ë„ (ì¶”ì„¸ íƒˆ ë•Œê¹Œì§€)
ë³´ìœ  ê¸°ê°„	ì§§ìŒ (ìˆ˜ì‹­ ë¶„ ~ ìˆ˜ ì‹œê°„)	ê¸¸ìŒ (ìˆ˜ ì‹œê°„ ~ ìˆ˜ì¼)
ì‹œì¥ ì¡°ê±´	íš¡ë³´/ë°•ìŠ¤ê¶Œì—ì„œ ê°•í•¨	ìƒìŠ¹ì¥/í•˜ë½ì¥ì—ì„œ ê°•í•¨
ì†ì‹¤ íŒ¨í„´	ë°˜ë“±ì´ ì•ˆ ë‚˜ì˜¬ ë•Œ	ì¶”ì„¸ê°€ êº¾ì¼ ë•Œ
2ï¸âƒ£ ë§¤ì¼ 1% ë‹¬ì„± ê°€ëŠ¥ì„± ë¶„ì„
ICT ê¸°ë°˜:
text
ê°€ì •: BTC/ETH 1ì‹œê°„ ë´‰ì—ì„œë§Œ ë¶„ì„
í‰ê·  ì‹ í˜¸: ì¼ 3~4íšŒ
í‰ê·  ìˆ˜ìµ: 1íšŒë‹¹ 0.4%
ì „ëµ: 3íšŒ Ã— 0.4% = 1.2% âœ“

í˜„ì‹¤:
â€¢ ì‹ í˜¸ ì¢‹ì€ ë‚ : 4íšŒ Ã— 0.5% = 2.0%
â€¢ ì‹ í˜¸ ì•½í•œ ë‚ : 2íšŒ Ã— 0.3% = 0.6%
â€¢ ì‹ í˜¸ ì—†ëŠ” ë‚ : 0íšŒ = 0%
â†’ ì¼ì£¼ì¼ ì¤‘ 3~4ì¼ ë§Œ 1% ì´ìƒ, ë‚˜ë¨¸ì§€ ìœ ì§€

ë¬¸ì œ: "ë§¤ì¼" 1%ëŠ” ê±°ì˜ ë¶ˆê°€ëŠ¥ (ì‹ í˜¸ ìì²´ê°€ ì•ˆ ë‚˜ì˜¤ëŠ” ë‚ ì´ ë§ìŒ)
ì¶”ì„¸ì¶”ì¢… ê¸°ë°˜:
text
ê°€ì •: 5ë¶„ë´‰ RSI + ì´í‰ì„  ì •ë°°ì—´ / ì—­ë°°ì—´
í‰ê·  ì‹ í˜¸: ì¼ 20~30íšŒ
í‰ê·  ìˆ˜ìµ: 1íšŒë‹¹ 0.1%~0.15%
ì „ëµ: 20íšŒ Ã— 0.1% = 2.0% âœ“

í˜„ì‹¤:
â€¢ ìƒìŠ¹ì¥: 25íšŒ Ã— 0.12% = 3.0%
â€¢ íš¡ë³´ì¥: 20íšŒ Ã— 0.08% = 1.6%
â€¢ í•˜ë½ì¥: 15íšŒ Ã— 0.05% = 0.75% (ì†ì‹¤ + ìˆ˜ìµ)
â†’ ê±°ì˜ ë§¤ì¼ 1% ë‚´ì™¸ ë‹¬ì„±

ë¬¸ì œ: ìˆ˜ìˆ˜ë£Œ ëˆ„ì ì´ ì‹¬í•¨ (20íšŒ Ã— 0.05% ìˆ˜ìˆ˜ë£Œ = 1%)
ğŸ“Š ì‹¬ì¸µ ë¶„ì„: ë§¤ì¼ 1% ë‹¬ì„±ì˜ í˜„ì‹¤ì„±
Scenario A: ICTë§Œ ì‚¬ìš©
text
ê¸°ê°„: 1ê°œì›” (20ê±°ë˜ì¼)

ìƒí™©ë³„ ë¶„í¬:
â€¢ ì‹ í˜¸ ì¢‹ì€ ë‚  (5ì¼): 4íšŒ Ã— 0.5% = +2.0%
â€¢ ì‹ í˜¸ ì¤‘ê°„ ë‚  (10ì¼): 2íšŒ Ã— 0.3% = +0.6%
â€¢ ì‹ í˜¸ ì—†ëŠ” ë‚  (5ì¼): 0íšŒ = 0%

ì›”ê°„ ìˆ˜ìµ: (5ì¼ Ã— 2%) + (10ì¼ Ã— 0.6%) + (5ì¼ Ã— 0%) 
        = 10% + 6% + 0% = 16%

í‰ê·  ì¼ì¼ ìˆ˜ìµ: 16% / 20ì¼ = 0.8% (ëª©í‘œ ë¯¸ë‹¬)
ì—°ê°„ ë³µë¦¬: 100ë§Œ ì› â†’ ì•½ 480ë§Œ ì› (38ë°° ì„±ì¥)

í˜„ì‹¤ì  í‰ê°€: âŒ "ë§¤ì¼" 1%ëŠ” ë¶ˆê°€ëŠ¥, í•˜ì§€ë§Œ ì•ˆì •ì 
Scenario B: ì¶”ì„¸ì¶”ì¢…ë§Œ ì‚¬ìš©
text
ê¸°ê°„: 1ê°œì›” (20ê±°ë˜ì¼)

ìƒí™©ë³„ ë¶„í¬:
â€¢ ìƒìŠ¹ì¥ (8ì¼): 25íšŒ Ã— 0.1% = +2.5%
â€¢ íš¡ë³´ì¥ (8ì¼): 20íšŒ Ã— 0.08% = +1.6%
â€¢ í•˜ë½ì¥ (4ì¼): 15íšŒ Ã— 0.05% = +0.75%

ì›”ê°„ ìˆ˜ìµ: (8ì¼ Ã— 2.5%) + (8ì¼ Ã— 1.6%) + (4ì¼ Ã— 0.75%)
        = 20% + 12.8% + 3% = 35.8%

í‰ê·  ì¼ì¼ ìˆ˜ìµ: 35.8% / 20ì¼ = 1.79% (ëª©í‘œ ì´ˆê³¼)
ì—°ê°„ ë³µë¦¬: 100ë§Œ ì› â†’ ì•½ 2,500ë§Œ ì› (25ë°° ì„±ì¥)

í˜„ì‹¤ì  í‰ê°€: âœ“ "ë§¤ì¼" 1% ë‹¬ì„± ê°€ëŠ¥, í•˜ì§€ë§Œ ìˆ˜ìˆ˜ë£Œ ìœ„í—˜ ìˆìŒ
Scenario C: í•˜ì´ë¸Œë¦¬ë“œ (ICT + ì¶”ì„¸ì¶”ì¢…)
text
ê¸°ê°„: 1ê°œì›” (20ê±°ë˜ì¼)

ì „ëµ:
â€¢ ì •ì˜¤(12ì‹œ): ICT ì‹ í˜¸ í™•ì¸ â†’ ìˆìœ¼ë©´ ì§„ì… (í° ê±°ë˜)
â€¢ ë‚˜ë¨¸ì§€ ì‹œê°„: ì¶”ì„¸ì¶”ì¢… ì‹ í˜¸ â†’ ìŠ¤ì¹¼í•‘ (ì‘ì€ ê±°ë˜)

ìƒí™©ë³„ ë¶„í¬:
â€¢ ICT ì‹ í˜¸ ìˆëŠ” ë‚  (7ì¼): ICT 1íšŒ Ã— 0.5% + ì¶”ì„¸ 15íšŒ Ã— 0.08% = 0.7% + 1.2% = +1.9%
â€¢ ICT ì‹ í˜¸ ì—†ëŠ” ë‚  (13ì¼): ì¶”ì„¸ 20íšŒ Ã— 0.08% = +1.6%

ì›”ê°„ ìˆ˜ìµ: (7ì¼ Ã— 1.9%) + (13ì¼ Ã— 1.6%)
        = 13.3% + 20.8% = 34.1%

í‰ê·  ì¼ì¼ ìˆ˜ìµ: 34.1% / 20ì¼ = 1.7% (ëª©í‘œ ì¶©ë¶„íˆ ë‹¬ì„±)
ì—°ê°„ ë³µë¦¬: 100ë§Œ ì› â†’ ì•½ 2,300ë§Œ ì› (23ë°° ì„±ì¥)

í˜„ì‹¤ì  í‰ê°€: âœ… "ë§¤ì¼" 1% ì•ˆì •ì  ë‹¬ì„± + ì¶”ì„¸ ì¶”ì¢…ì˜ ë†’ì€ íšŒì „ìœ¨ + ICTì˜ ê³ ìŠ¹ë¥  ê²°í•©
ğŸ† ê²°ë¡ : "ë§¤ì¼ 1% ìˆ˜ìµ"ì„ ìœ„í•œ ìµœì  ì „ëµ
ì¶”ì²œ: í•˜ì´ë¸Œë¦¬ë“œ (ICT + ì¶”ì„¸ì¶”ì¢…) ì¡°í•©
ì´ìœ :

ICTì˜ ì¥ì : ê³ ìŠ¹ë¥ (75%), í° ìˆ˜ìµ(0.5% ì´ìƒ)

ì¶”ì„¸ì¶”ì¢…ì˜ ì¥ì : ë§¤ì¼ ì‹ í˜¸, ë†’ì€ íšŒì „ìœ¨(20~30íšŒ)

ê²°í•© íš¨ê³¼: ICT ì‹¤íŒ¨ ë‚ ë„ ì¶”ì„¸ì¶”ì¢…ìœ¼ë¡œ ì»¤ë²„

ğŸ› ï¸ "ë§¤ì¼ 1% ìˆ˜ìµ" ìë™ë§¤ë§¤ ë´‡ ê°œë°œ ë¡œë“œë§µ
Phase 1: Core Infrastructure (2ì£¼)
python
# src/hybrid_bot.py (ìƒˆë¡œìš´ í†µí•© ì—”ì§„)

class HybridTradingBot:
    """
    ICT + Trend Following í•˜ì´ë¸Œë¦¬ë“œ ë´‡
    ëª©í‘œ: ë§¤ì¼ 1% ìˆ˜ìµë¥  ë‹¬ì„±
    """
    
    def __init__(self):
        self.symbols = ["KRW-BTC", "KRW-ETH", "KRW-XRP"]
        self.ict_analyzer = ICTAnalyzer()
        self.trend_analyzer = TrendFollowingAnalyzer()
        self.position_manager = PositionManager()
        self.daily_target = 1.0  # 1%
        self.daily_profit = 0.0
    
    def morning_routine(self):
        """
        09:00 - ë§¤ì¼ ì•„ì¹¨ ë£¨í‹´
        (ICT ì‹ í˜¸ ìŠ¤ìº” - ì¼ 1íšŒ)
        """
        for symbol in self.symbols:
            # 1H ì°¨íŠ¸ ë¶„ì„
            df_1h = self.upbit.get_candles(symbol, interval="60m", count=50)
            
            signal = self.ict_analyzer.analyze_confluence(df_1h)
            
            if signal["ready_to_trade"]:
                self.execute_ict_trade(symbol, signal)
    
    def intraday_routine(self):
        """
        ë§¤ 10ë¶„ë§ˆë‹¤ ë°˜ë³µ
        (ì¶”ì„¸ ì¶”ì¢… ìŠ¤ìº˜í•‘ - ì¼ 100+ íšŒ)
        """
        for symbol in self.symbols:
            # 5M ì°¨íŠ¸ ë¶„ì„
            df_5m = self.upbit.get_candles(symbol, interval="5m", count=30)
            
            trend_signal = self.trend_analyzer.analyze(df_5m)
            
            if trend_signal["action"] in ["BUY", "SELL"]:
                self.execute_scalp_trade(symbol, trend_signal)
            
            # ì¼ì¼ ëª©í‘œ ë‹¬ì„± ì²´í¬
            if self.daily_profit >= self.daily_target:
                self.logger.info(f"âœ… Daily Target Achieved: {self.daily_profit:.2f}%")
                # ë‚˜ë¨¸ì§€ ê±°ë˜ëŠ” ì¶•ì†Œ (ë¦¬ìŠ¤í¬ ê´€ë¦¬)
    
    def execute_ict_trade(self, symbol, signal):
        """
        ê³ ìŠ¹ë¥  ICT ê±°ë˜ (í° í¬ì§€ì…˜)
        """
        position_size = self.calc_position_size(symbol, aggressive=True)  # 5%
        
        orderbook = self.upbit.get_orderbook(symbol)
        bid_price = orderbook['orderbook_units'][0]['bid_price']
        
        order = self.upbit.buy_limit_order(symbol, bid_price, position_size)
        
        self.position_manager.add_position(
            symbol=symbol,
            entry_price=bid_price,
            strategy="ICT",
            size=position_size,
            target_profit=1.0,  # 1% ìµì ˆ
            stop_loss=2.0  # 2% ì†ì ˆ
        )
    
    def execute_scalp_trade(self, symbol, signal):
        """
        ê³ ë¹ˆë„ ì¶”ì„¸ ì¶”ì¢… (ì‘ì€ í¬ì§€ì…˜)
        """
        position_size = self.calc_position_size(symbol, aggressive=False)  # 1%
        
        if signal["action"] == "BUY":
            orderbook = self.upbit.get_orderbook(symbol)
            bid_price = orderbook['orderbook_units'][0]['bid_price']
            order = self.upbit.buy_limit_order(symbol, bid_price, position_size)
        
        self.position_manager.add_position(
            symbol=symbol,
            entry_price=signal["entry_price"],
            strategy="TREND",
            size=position_size,
            target_profit=0.3,  # 0.3% ë¹ ë¥¸ ìµì ˆ
            stop_loss=0.5  # 0.5% ë¹ ë¥¸ ì†ì ˆ
        )
    
    def calc_position_size(self, symbol, aggressive=True):
        """
        ë™ì  í¬ì§€ì…˜ í¬ê¸° ê³„ì‚°
        """
        portfolio_value = self.get_portfolio_value()
        
        if self.daily_profit >= self.daily_target:
            # ëª©í‘œ ë‹¬ì„± í›„: ë³´ìˆ˜ì 
            return portfolio_value * 0.01
        elif aggressive:
            # ICT ì‹ í˜¸: ê³µê²©ì 
            return portfolio_value * 0.05
        else:
            # ì¶”ì„¸ ì¶”ì¢…: ì¤‘ê°„
            return portfolio_value * 0.02
    
    def run(self):
        """
        ë©”ì¸ ë£¨í”„
        """
        while True:
            current_hour = datetime.now().hour
            
            # 09:00 ì•„ì¹¨ ë£¨í‹´
            if current_hour == 9:
                self.morning_routine()
            
            # ë§¤ 10ë¶„ë§ˆë‹¤
            self.intraday_routine()
            
            # ìì •ì— ë¦¬ì…‹
            if current_hour == 0:
                self.daily_profit = 0.0
            
            time.sleep(600)  # 10ë¶„
Phase 2: í¬ì§€ì…˜ ê´€ë¦¬ì (1ì£¼)
python
# src/position_manager.py

class PositionManager:
    """
    ìˆ˜ìµ/ì†ì‹¤ ì¶”ì  ë° ìë™ ìµì ˆ/ì†ì ˆ
    """
    
    def __init__(self):
        self.positions = {}
        self.daily_profit = 0.0
    
    def add_position(self, symbol, entry_price, strategy, size, target_profit, stop_loss):
        """
        í¬ì§€ì…˜ ì¶”ê°€
        """
        self.positions[symbol] = {
            "entry_price": entry_price,
            "strategy": strategy,  # "ICT" or "TREND"
            "size": size,
            "target_profit": target_profit,
            "stop_loss": stop_loss,
            "entry_time": datetime.now()
        }
    
    def update_positions(self, current_prices):
        """
        ë§¤ 10ì´ˆë§ˆë‹¤ ì‹¤í–‰
        í˜„ì¬ ê°€ê²© ê¸°ì¤€ìœ¼ë¡œ ìµì ˆ/ì†ì ˆ ì²´í¬
        """
        for symbol, position in list(self.positions.items()):
            current_price = current_prices[symbol]
            entry_price = position["entry_price"]
            
            # ìˆ˜ìµë¥  ê³„ì‚°
            profit_percent = (current_price - entry_price) / entry_price * 100
            
            # ìµì ˆ ì²´í¬
            if profit_percent >= position["target_profit"]:
                self.close_position(symbol, "TAKE_PROFIT")
                self.daily_profit += profit_percent
            
            # ì†ì ˆ ì²´í¬
            elif profit_percent <= -position["stop_loss"]:
                self.close_position(symbol, "STOP_LOSS")
                self.daily_profit += profit_percent
            
            # íƒ€ì„ì•„ì›ƒ (5ë¶„ ì´ìƒ í¬ì§€ì…˜ ìœ ì§€)
            elif (datetime.now() - position["entry_time"]).seconds > 300:
                if position["strategy"] == "TREND":  # ì¶”ì„¸ ì¶”ì¢…ë§Œ íƒ€ì„ì•„ì›ƒ
                    self.close_position(symbol, "TIMEOUT")
    
    def close_position(self, symbol, reason):
        """
        í¬ì§€ì…˜ ì²­ì‚°
        """
        upbit = pyupbit.Upbit(...)
        upbit.sell_market_order(symbol, self.positions[symbol]["size"])
        
        print(f"[CLOSE] {symbol} - Reason: {reason}")
        del self.positions[symbol]
Phase 3: ìœ„í—˜ ê´€ë¦¬ (1ì£¼)
python
# src/risk_control.py

class RiskControl:
    """
    í•˜ë£¨ 1% ë‹¬ì„± í›„ ë¦¬ìŠ¤í¬ ê°ì†Œ
    ì—°ì‡„ ì†ì‹¤ ë°©ì§€
    """
    
    def __init__(self, daily_target=1.0, max_daily_loss=3.0):
        self.daily_target = daily_target
        self.max_daily_loss = max_daily_loss
        self.daily_profit = 0.0
        self.trades_today = 0
        self.max_trades = 100
    
    def check_daily_status(self):
        """
        ì¼ì¼ ëª©í‘œ ë‹¬ì„± ì—¬ë¶€ í™•ì¸
        """
        if self.daily_profit >= self.daily_target:
            return "TARGET_ACHIEVED"  # ê±°ë˜ ì¶•ì†Œ
        elif self.daily_profit <= -self.max_daily_loss:
            return "MAX_LOSS_HIT"  # ê±°ë˜ ì¤‘ë‹¨
        elif self.trades_today >= self.max_trades:
            return "MAX_TRADES_HIT"  # ê±°ë˜ ì¤‘ë‹¨
        else:
            return "CONTINUE"
    
    def adjust_strategy(self, status):
        """
        ìƒíƒœì— ë”°ë¼ ì „ëµ ì¡°ì •
        """
        if status == "TARGET_ACHIEVED":
            # ì¶”ì„¸ ì¶”ì¢…ë§Œ ì‘ì€ í¬ì§€ì…˜ìœ¼ë¡œ ê³„ì†
            return {"ict_enabled": False, "scalp_size_mult": 0.5}
        elif status in ["MAX_LOSS_HIT", "MAX_TRADES_HIT"]:
            # ëª¨ë“  ê±°ë˜ ì¤‘ë‹¨
            return {"ict_enabled": False, "scalp_enabled": False}
        else:
            # ì •ìƒ ëª¨ë“œ
            return {"ict_enabled": True, "scalp_size_mult": 1.0}
Phase 4: ë°±í…ŒìŠ¤íŠ¸ ë° ê²€ì¦ (2ì£¼)
python
# test/backtest_hybrid.py

def backtest_hybrid_strategy():
    """
    ê³¼ê±° 1ê°œì›” ë°ì´í„°ë¡œ ë°±í…ŒìŠ¤íŠ¸
    """
    # BTC 1ê°œì›” ë°ì´í„° ë¡œë“œ
    df = pyupbit.get_ohlcv("KRW-BTC", interval="1d", count=30)
    
    # ICT ì‹ í˜¸ 100% ì •í™•ë„ ê°€ì • (í˜„ì‹¤ì€ 75%)
    # ì¶”ì„¸ ì¶”ì¢… 60% ì •í™•ë„ ê°€ì •
    
    results = {
        "total_profit": 0,
        "daily_profits": [],
        "win_rate": 0,
        "max_drawdown": 0
    }
    
    for day in df.iterrows():
        # ì‹œë®¬ë ˆì´ì…˜...
        pass
    
    return results

# ì˜ˆìƒ ê²°ê³¼:
# Daily Avg: 1.2% ~ 1.8%
# Win Rate: 65% ~ 70%
# Annual Return: 500% ~ 700% (ë³µë¦¬)
ğŸ“ˆ "ë§¤ì¼ 1% ë³µë¦¬" ë¡œë“œë§µ
Phase	ê¸°ê°„	ëª©í‘œ	ìƒíƒœ
1. Core Infrastructure	2ì£¼	ICT + ì¶”ì„¸ í†µí•© ì—”ì§„	â³
2. Position Manager	1ì£¼	ìë™ ìµì ˆ/ì†ì ˆ	â³
3. Risk Control	1ì£¼	ì¼ì¼ ëª©í‘œ ë‹¬ì„± í›„ ì¶•ì†Œ	â³
4. Backtest	2ì£¼	ê³¼ê±° ë°ì´í„° ê²€ì¦	â³
5. Demo Trading	1ì£¼	ì‹¤ê±°ë˜ ì‹œë®¬ë ˆì´ì…˜	â³
6. Live Deploy	-	ì†ŒëŸ‰ ìê¸ˆìœ¼ë¡œ ì‹œì‘	â³
ğŸ¯ ìµœì¢… ê²°ë¡ 
ICT vs ì¶”ì„¸ì¶”ì¢…: ë‹¨ë…ì€ ìœ„í—˜, í•˜ì´ë¸Œë¦¬ë“œê°€ ìµœê³ 
ICTë§Œ:

âœ… ê³ ìŠ¹ë¥  (75%)

âŒ ì‹ í˜¸ ë¶ˆì•ˆì • (ì¼ 0~4íšŒ)

âŒ ë§¤ì¼ 1%ëŠ” ê±°ì˜ ë¶ˆê°€ëŠ¥

ì¶”ì„¸ì¶”ì¢…ë§Œ:

âœ… ë§¤ì¼ ì‹ í˜¸ (ì¼ 20~30íšŒ)

âŒ ë‚®ì€ ìŠ¹ë¥  (60%)

âŒ ìˆ˜ìˆ˜ë£Œ ì§€ì˜¥

í•˜ì´ë¸Œë¦¬ë“œ (ICT + ì¶”ì„¸):

âœ… ë§¤ì¼ 1% ì•ˆì •ì  ë‹¬ì„±

âœ… ICTì˜ ê³ ìŠ¹ë¥  + ì¶”ì„¸ì˜ ë†’ì€ íšŒì „ìœ¨

âœ… ìœ„í—˜ ê´€ë¦¬ ê°•í™”

âœ… ì‹¬ë¦¬ ì•ˆì •ì„±

ì½”ë”© ì‹œì‘í•˜ì‹œê² ìŠµë‹ˆê¹Œ? ì•„ë‹ˆë©´ ë” ê¹Šì€ í† ë¡ ì´ í•„ìš”í•˜ì‹ ê°€ìš”?

ì ì´ì œ ì½”ë”©ì„ ì‹œì‘í•´ë³´ì. ëŠë¦¬ê²Œ ê²€ìƒ‰í•˜ê³  ëŠë¦¬ê²Œ ìƒê°í•´ë„ ë˜ë‹ˆê¹Œ ìµœëŒ€í•œ ì—ëŸ¬ì—†ì´ ê¹”ë”í•˜ê²Œ ì½”ë”© êµ¬í˜„ ë¶€íƒí•´. ì—…ë¹„íŠ¸api + railway + git ë°°í¬ë‹ˆê¹Œ ì—ëŸ¬ê°€ ì•ˆë‚˜ì•¼í•˜ê±°ë“ . ë‹¤íšŒí˜¸ì¶œë„ ì¡°ì‹¬í•´ì¤˜.
ì•Œê² ìŠµë‹ˆë‹¤. í”„ë¡œë•ì…˜ ë ˆë²¨ì˜ ì•ˆì •ì ì¸ ì½”ë“œë¥¼ ì‘ì„±í•˜ê² ìŠµë‹ˆë‹¤. ì—ëŸ¬ ì²˜ë¦¬, API ë ˆì´íŠ¸ ë¦¬ë°‹, ìºì‹±ì„ ëª¨ë‘ ê³ ë ¤í•˜ì—¬ ì§„í–‰í•©ë‹ˆë‹¤.

ë¨¼ì € ì „ì²´ ì•„í‚¤í…ì²˜ì™€ íŒŒì¼ êµ¬ì¡°ë¥¼ ëª…í™•íˆ í•œ í›„, í•˜ë‚˜ì”© ì°¨ê·¼ì°¨ê·¼ êµ¬í˜„í•˜ê² ìŠµë‹ˆë‹¤.

ğŸ“ í”„ë¡œì íŠ¸ êµ¬ì¡° (ìµœì¢…)
text
hybrid-trading-bot/
â”œâ”€â”€ .gitignore
â”œâ”€â”€ .env.example
â”œâ”€â”€ README.md
â”œâ”€â”€ requirements.txt
â”œâ”€â”€ config.py
â”œâ”€â”€ main.py
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ logger.py                 # ë¡œê¹… ê´€ë¦¬
â”‚   â”œâ”€â”€ upbit_client.py           # ì—…ë¹„íŠ¸ API ë˜í¼
â”‚   â”œâ”€â”€ ict_analyzer.py           # ICT ê¸°ë²• ë¶„ì„
â”‚   â”œâ”€â”€ trend_analyzer.py         # ì¶”ì„¸ ì¶”ì¢… ë¶„ì„
â”‚   â”œâ”€â”€ position_manager.py       # í¬ì§€ì…˜ ê´€ë¦¬
â”‚   â”œâ”€â”€ risk_control.py           # ìœ„í—˜ ê´€ë¦¬
â”‚   â”œâ”€â”€ hybrid_bot.py             # í†µí•© ë´‡ ì—”ì§„
â”‚   â””â”€â”€ cache.py                  # API ìºì‹± (ë ˆì´íŠ¸ ë¦¬ë°‹ ë°©ì§€)
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ test_ict_analyzer.py
â”‚   â”œâ”€â”€ test_trend_analyzer.py
â”‚   â””â”€â”€ test_backtest.py
â””â”€â”€ .github/
    â””â”€â”€ workflows/
        â””â”€â”€ deploy.yml            # Railway ìë™ ë°°í¬
ğŸš€ Step 1: ê¸°ì´ˆ ì„¤ì • íŒŒì¼ë“¤
1-1. .env.example (ë¯¼ê° ì •ë³´ í…œí”Œë¦¿)
bash
# .env.example
UPBIT_ACCESS_KEY=your_access_key_here
UPBIT_SECRET_KEY=your_secret_key_here
UPBIT_WEBHOOK_SECRET=your_webhook_secret_here

# ë´‡ ì„¤ì •
SYMBOLS=KRW-BTC,KRW-ETH,KRW-XRP
INITIAL_CAPITAL=1000000
DAILY_TARGET_PERCENT=1.0
MAX_DAILY_LOSS_PERCENT=3.0

# Railway í™˜ê²½
ENVIRONMENT=production
LOG_LEVEL=INFO
1-2. requirements.txt
text
pyupbit==0.2.30
pandas==2.0.3
numpy==1.24.3
python-dotenv==1.0.0
requests==2.31.0
APScheduler==3.10.4
Flask==2.3.2
gunicorn==21.2.0
pymongo==4.4.0
redis==4.6.0
1-3. config.py (ëª¨ë“  ì„¤ì • ì¤‘ì•™í™”)
python
# config.py
import os
from dotenv import load_dotenv
from datetime import datetime

load_dotenv()

class Config:
    """í”„ë¡œë•ì…˜ ê¸°ë³¸ ì„¤ì •"""
    
    # ===== API ì„¤ì • =====
    UPBIT_ACCESS_KEY = os.getenv("UPBIT_ACCESS_KEY")
    UPBIT_SECRET_KEY = os.getenv("UPBIT_SECRET_KEY")
    
    # API ë ˆì´íŠ¸ ë¦¬ë°‹ (ë¶„ë‹¹ 600íšŒ, ì•ˆì „ë§ˆì§„ 80%)
    API_RATE_LIMIT = 480  # ë¶„ë‹¹ ìµœëŒ€ í˜¸ì¶œ ìˆ˜
    API_CACHE_TTL = 30  # ìºì‹œ ìœ ì§€ì‹œê°„ (ì´ˆ)
    
    # ===== ë´‡ ì„¤ì • =====
    SYMBOLS = os.getenv("SYMBOLS", "KRW-BTC,KRW-ETH,KRW-XRP").split(",")
    INITIAL_CAPITAL = int(os.getenv("INITIAL_CAPITAL", 1000000))
    
    # ===== ICT ì„¤ì • =====
    ICT_CONFIG = {
        "enabled": True,
        "timeframe": "60m",  # 1ì‹œê°„ ë´‰
        "min_confluence": 2,  # 2ê°œ ì´ìƒ ì‹ í˜¸
        "min_confidence": 70,  # 70% ì‹ ë¢°ë„
        "position_size_ratio": 0.05,  # í¬íŠ¸í´ë¦¬ì˜¤ 5%
        "take_profit_percent": 1.0,  # 1% ìµì ˆ
        "stop_loss_percent": 2.0,  # 2% ì†ì ˆ
        "check_interval": 3600,  # 1ì‹œê°„ë§ˆë‹¤ ì²´í¬
    }
    
    # ===== ì¶”ì„¸ ì¶”ì¢… ì„¤ì • =====
    TREND_CONFIG = {
        "enabled": True,
        "timeframe": "5m",  # 5ë¶„ ë´‰
        "rsi_period": 14,
        "rsi_overbought": 70,
        "rsi_oversold": 30,
        "position_size_ratio": 0.01,  # í¬íŠ¸í´ë¦¬ì˜¤ 1%
        "take_profit_percent": 0.3,  # 0.3% ë¹ ë¥¸ ìµì ˆ
        "stop_loss_percent": 0.5,  # 0.5% ë¹ ë¥¸ ì†ì ˆ
        "check_interval": 300,  # 5ë¶„ë§ˆë‹¤ ì²´í¬
        "max_timeout_seconds": 300,  # 5ë¶„ íƒ€ì„ì•„ì›ƒ
    }
    
    # ===== ìœ„í—˜ ê´€ë¦¬ =====
    RISK_CONFIG = {
        "daily_target_percent": float(os.getenv("DAILY_TARGET_PERCENT", 1.0)),
        "max_daily_loss_percent": float(os.getenv("MAX_DAILY_LOSS_PERCENT", 3.0)),
        "max_daily_trades": 100,
        "max_concurrent_positions": 10,
        "strategy_switch_at_target": True,  # ëª©í‘œ ë‹¬ì„± í›„ ì¶”ì„¸ë§Œ ì‹¤í–‰
    }
    
    # ===== ë¡œê¹… =====
    LOG_LEVEL = os.getenv("LOG_LEVEL", "INFO")
    LOG_FORMAT = "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
    LOG_FILE = f"logs/bot_{datetime.now().strftime('%Y%m%d')}.log"
    
    # ===== í™˜ê²½ =====
    ENVIRONMENT = os.getenv("ENVIRONMENT", "development")
    DEBUG = ENVIRONMENT == "development"

class DevelopmentConfig(Config):
    """ê°œë°œ í™˜ê²½"""
    DEBUG = True
    API_RATE_LIMIT = 100  # ëŠë¦¼ (API í…ŒìŠ¤íŠ¸ìš©)
    
class ProductionConfig(Config):
    """í”„ë¡œë•ì…˜ í™˜ê²½ (Railway)"""
    DEBUG = False
    API_RATE_LIMIT = 480  # ì•ˆì „í•œ ì†ë„

def get_config():
    """í˜„ì¬ í™˜ê²½ì— ë§ëŠ” ì„¤ì • ë°˜í™˜"""
    env = os.getenv("ENVIRONMENT", "development")
    return ProductionConfig if env == "production" else DevelopmentConfig
ğŸ”§ Step 2: í•µì‹¬ ìœ í‹¸ë¦¬í‹° ëª¨ë“ˆ
2-1. src/logger.py (ì¤‘ì•™í™” ë¡œê¹…)
python
# src/logger.py
import logging
import os
from config import Config

def setup_logger(name):
    """
    ì¤‘ì•™í™”ëœ ë¡œê±° ì„¤ì •
    Railwayì— ë§ì¶¤ (stdoutë§Œ ì‚¬ìš©)
    """
    logger = logging.getLogger(name)
    logger.setLevel(logging.DEBUG)
    
    # Formatter
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )
    
    # Console Handler (Railway ê¶Œì¥)
    console_handler = logging.StreamHandler()
    console_handler.setLevel(getattr(logging, Config.LOG_LEVEL))
    console_handler.setFormatter(formatter)
    
    logger.addHandler(console_handler)
    
    return logger

# ê¸€ë¡œë²Œ ì¸ìŠ¤í„´ìŠ¤
app_logger = setup_logger("hybrid-bot")
2-2. src/cache.py (API ë ˆì´íŠ¸ ë¦¬ë°‹ ë°©ì§€)
python
# src/cache.py
import time
from functools import wraps
from collections import defaultdict
from config import Config
from src.logger import app_logger

class RateLimiter:
    """
    API í˜¸ì¶œ ë ˆì´íŠ¸ ë¦¬ë¯¸í„°
    ë¶„ë‹¹ 600íšŒ ì œí•œ ì¤€ìˆ˜
    """
    
    def __init__(self, calls_per_minute=600):
        self.calls_per_minute = calls_per_minute
        self.min_interval = 60.0 / calls_per_minute
        self.last_called = {}
    
    def wait_if_needed(self, api_name):
        """
        í•„ìš”í•˜ë©´ ëŒ€ê¸°
        """
        now = time.time()
        
        if api_name in self.last_called:
            elapsed = now - self.last_called[api_name]
            if elapsed < self.min_interval:
                wait_time = self.min_interval - elapsed
                app_logger.debug(f"Rate limit: {api_name} wait {wait_time:.2f}s")
                time.sleep(wait_time)
        
        self.last_called[api_name] = time.time()

class DataCache:
    """
    ë°ì´í„° ìºì‹± (30ì´ˆ TTL)
    ë™ì¼í•œ API í˜¸ì¶œ ë°˜ë³µ ë°©ì§€
    """
    
    def __init__(self, ttl_seconds=30):
        self.cache = {}
        self.ttl = ttl_seconds
    
    def get(self, key):
        """ìºì‹œì—ì„œ ë°ì´í„° ì¡°íšŒ"""
        if key in self.cache:
            data, timestamp = self.cache[key]
            if time.time() - timestamp < self.ttl:
                return data
            else:
                del self.cache[key]
        return None
    
    def set(self, key, data):
        """ìºì‹œì— ë°ì´í„° ì €ì¥"""
        self.cache[key] = (data, time.time())
    
    def clear_expired(self):
        """ë§Œë£Œëœ ìºì‹œ ì‚­ì œ"""
        now = time.time()
        expired_keys = [
            k for k, (_, ts) in self.cache.items()
            if now - ts >= self.ttl
        ]
        for k in expired_keys:
            del self.cache[k]

# ê¸€ë¡œë²Œ ì¸ìŠ¤í„´ìŠ¤
rate_limiter = RateLimiter(Config.API_RATE_LIMIT)
data_cache = DataCache(Config.API_CACHE_TTL)
ğŸ“Š Step 3: API í´ë¼ì´ì–¸íŠ¸
3-1. src/upbit_client.py (ì—…ë¹„íŠ¸ API ë˜í¼)
python
# src/upbit_client.py
import pyupbit
import time
from config import Config
from src.logger import app_logger
from src.cache import rate_limiter, data_cache

class UpbitClient:
    """
    ì—…ë¹„íŠ¸ API ë˜í¼
    ë ˆì´íŠ¸ ë¦¬ë¯¸íŠ¸ + ìºì‹± + ì—ëŸ¬ ì²˜ë¦¬
    """
    
    def __init__(self):
        self.upbit = pyupbit.Upbit(
            access_key=Config.UPBIT_ACCESS_KEY,
            secret_key=Config.UPBIT_SECRET_KEY
        )
        self.retry_count = 3
        self.retry_delay = 2
    
    def _retry_wrapper(self, func, *args, **kwargs):
        """
        ì¬ì‹œë„ ë¡œì§
        ì¼ì‹œì  ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ ì²˜ë¦¬
        """
        for attempt in range(self.retry_count):
            try:
                rate_limiter.wait_if_needed(func.__name__)
                return func(*args, **kwargs)
            except Exception as e:
                if attempt < self.retry_count - 1:
                    wait_time = self.retry_delay * (attempt + 1)
                    app_logger.warning(
                        f"API call failed (attempt {attempt + 1}/{self.retry_count}). "
                        f"Retrying in {wait_time}s... Error: {str(e)}"
                    )
                    time.sleep(wait_time)
                else:
                    app_logger.error(f"API call failed after {self.retry_count} attempts: {str(e)}")
                    raise
    
    def get_candles(self, symbol, interval="60m", count=50):
        """
        ìº”ë“¤ ë°ì´í„° ì¡°íšŒ (ìºì‹± ì ìš©)
        """
        cache_key = f"candle_{symbol}_{interval}_{count}"
        cached = data_cache.get(cache_key)
        
        if cached is not None:
            app_logger.debug(f"Using cached candles for {symbol} {interval}")
            return cached
        
        def fetch():
            if interval == "1d":
                return pyupbit.get_ohlcv(symbol, interval="day", count=count)
            else:
                unit = int(interval.replace("m", ""))
                return pyupbit.get_ohlcv(symbol, interval=f"minutes{unit}", count=count)
        
        try:
            df = self._retry_wrapper(fetch)
            data_cache.set(cache_key, df)
            return df
        except Exception as e:
            app_logger.error(f"Failed to get candles for {symbol}: {str(e)}")
            raise
    
    def get_orderbook(self, symbol):
        """
        í˜¸ê°€ì°½ ì¡°íšŒ (ìºì‹± X - ì‹¤ì‹œê°„ í•„ìš”)
        """
        cache_key = f"orderbook_{symbol}"
        cached = data_cache.get(cache_key)
        
        if cached is not None:
            return cached
        
        try:
            data = self._retry_wrapper(self.upbit.get_orderbook, symbol)
            data_cache.set(cache_key, data)
            return data
        except Exception as e:
            app_logger.error(f"Failed to get orderbook for {symbol}: {str(e)}")
            raise
    
    def get_balance(self, symbol="KRW"):
        """
        ì”ì•¡ ì¡°íšŒ
        """
        try:
            return self._retry_wrapper(self.upbit.get_balances, symbol)
        except Exception as e:
            app_logger.error(f"Failed to get balance for {symbol}: {str(e)}")
            raise
    
    def buy_limit_order(self, symbol, price, volume):
        """
        ì§€ì •ê°€ ë§¤ìˆ˜
        """
        try:
            order = self._retry_wrapper(
                self.upbit.buy_limit_order,
                symbol,
                price,
                volume
            )
            app_logger.info(f"Buy limit order placed: {symbol} @ {price} x {volume}")
            return order
        except Exception as e:
            app_logger.error(f"Failed to place buy order for {symbol}: {str(e)}")
            raise
    
    def sell_limit_order(self, symbol, price, volume):
        """
        ì§€ì •ê°€ ë§¤ë„
        """
        try:
            order = self._retry_wrapper(
                self.upbit.sell_limit_order,
                symbol,
                price,
                volume
            )
            app_logger.info(f"Sell limit order placed: {symbol} @ {price} x {volume}")
            return order
        except Exception as e:
            app_logger.error(f"Failed to place sell order for {symbol}: {str(e)}")
            raise
    
    def buy_market_order(self, symbol, krw):
        """
        ì‹œì¥ê°€ ë§¤ìˆ˜ (ê¸´ê¸‰ ì²­ì‚°ìš©)
        """
        try:
            order = self._retry_wrapper(self.upbit.buy_market_order, symbol, krw)
            app_logger.info(f"Buy market order: {symbol} for {krw} KRW")
            return order
        except Exception as e:
            app_logger.error(f"Failed to place market buy for {symbol}: {str(e)}")
            raise
    
    def sell_market_order(self, symbol, volume):
        """
        ì‹œì¥ê°€ ë§¤ë„ (ê¸´ê¸‰ ì²­ì‚°ìš©)
        """
        try:
            order = self._retry_wrapper(self.upbit.sell_market_order, symbol, volume)
            app_logger.info(f"Sell market order: {symbol} x {volume}")
            return order
        except Exception as e:
            app_logger.error(f"Failed to place market sell for {symbol}: {str(e)}")
            raise
    
    def get_orders(self, symbol):
        """
        ì§„í–‰ ì¤‘ì¸ ì£¼ë¬¸ ì¡°íšŒ
        """
        try:
            return self._retry_wrapper(self.upbit.get_orders, symbol)
        except Exception as e:
            app_logger.error(f"Failed to get orders for {symbol}: {str(e)}")
            raise
    
    def cancel_order(self, uuid):
        """
        ì£¼ë¬¸ ì·¨ì†Œ
        """
        try:
            result = self._retry_wrapper(self.upbit.cancel_order, uuid)
            app_logger.info(f"Order cancelled: {uuid}")
            return result
        except Exception as e:
            app_logger.error(f"Failed to cancel order {uuid}: {str(e)}")
            raise
ğŸ“ˆ Step 4: ë¶„ì„ ëª¨ë“ˆ
4-1. src/ict_analyzer.py (ICT ê¸°ë²•)
python
# src/ict_analyzer.py
import pandas as pd
from src.logger import app_logger

class ICTAnalyzer:
    """
    ICT (Inner Circle Trader) ê¸°ë²•
    Order Block + Fair Value Gap + Liquidity Pool
    """
    
    def __init__(self, min_confluence=2):
        self.min_confluence = min_confluence
    
    def detect_order_block(self, df):
        """
        Order Block ê°ì§€
        ê°•í•œ ìƒìŠ¹/í•˜ë½ í›„ ëì 
        """
        if len(df) < 5:
            return {"found": False}
        
        recent = df.iloc[-5:].copy()
        recent['change'] = recent['close'].diff()
        
        # ìƒìŠ¹ ì˜¤ë”ë¸”ë¡
        ups = (recent['change'] > 0).sum()
        if ups >= 2:
            ob_level = recent['high'].iloc[-1]
            return {
                "found": True,
                "type": "bullish_ob",
                "level": ob_level,
                "strength": ups / 3
            }
        
        # í•˜ë½ ì˜¤ë”ë¸”ë¡
        downs = (recent['change'] < 0).sum()
        if downs >= 2:
            ob_level = recent['low'].iloc[-1]
            return {
                "found": True,
                "type": "bearish_ob",
                "level": ob_level,
                "strength": downs / 3
            }
        
        return {"found": False}
    
    def detect_fair_value_gap(self, df):
        """
        Fair Value Gap ê°ì§€
        ì—°ì† ìº”ë“¤ ê°„ ê°­
        """
        if len(df) < 3:
            return {"found": False}
        
        for i in range(len(df) - 3, len(df) - 1):
            candle_1 = df.iloc[i]
            candle_2 = df.iloc[i + 1]
            
            # ìƒìŠ¹ ê°­
            if candle_1['high'] < candle_2['low']:
                gap_size = (candle_2['low'] - candle_1['high']) / candle_1['high'] * 100
                if gap_size > 0.05:  # 0.05% ì´ìƒë§Œ ì¸ì •
                    return {
                        "found": True,
                        "type": "bullish_fvg",
                        "gap_bottom": candle_1['high'],
                        "gap_top": candle_2['low'],
                        "gap_size_percent": gap_size
                    }
            
            # í•˜ë½ ê°­
            if candle_1['low'] > candle_2['high']:
                gap_size = (candle_1['low'] - candle_2['high']) / candle_1['low'] * 100
                if gap_size > 0.05:
                    return {
                        "found": True,
                        "type": "bearish_fvg",
                        "gap_top": candle_1['low'],
                        "gap_bottom": candle_2['high'],
                        "gap_size_percent": gap_size
                    }
        
        return {"found": False}
    
    def detect_liquidity_pool(self, df, lookback=20):
        """
        Liquidity Pool ê°ì§€
        ìµœê·¼ ê³ ì /ì €ì  ê·¼ì²˜
        """
        if len(df) < lookback:
            return {"found": False}
        
        recent = df.iloc[-lookback:]
        
        highest = recent['high'].max()
        lowest = recent['low'].min()
        current_price = df.iloc[-1]['close']
        
        # ìƒìŠ¹ Liquidity
        dist_high = (highest - current_price) / current_price * 100
        if 0 < dist_high < 2:
            return {
                "found": True,
                "type": "high_liquidity",
                "level": highest,
                "distance_percent": dist_high
            }
        
        # í•˜ë½ Liquidity
        dist_low = (current_price - lowest) / current_price * 100
        if 0 < dist_low < 2:
            return {
                "found": True,
                "type": "low_liquidity",
                "level": lowest,
                "distance_percent": dist_low
            }
        
        return {"found": False}
    
    def analyze(self, df):
        """
        í†µí•© ë¶„ì„: Confluence ê³„ì‚°
        """
        ob = self.detect_order_block(df)
        fvg = self.detect_fair_value_gap(df)
        liq = self.detect_liquidity_pool(df)
        
        confluence = sum([
            1 for x in [ob.get("found"), fvg.get("found"), liq.get("found")]
            if x
        ])
        
        signal = {
            "confluence": confluence,
            "ready": confluence >= self.min_confluence,
            "order_block": ob,
            "fair_value_gap": fvg,
            "liquidity_pool": liq,
            "confidence": (confluence / 3) * 100
        }
        
        if signal["ready"]:
            app_logger.info(f"ICT Signal: Confluence {confluence}/3")
        
        return signal
4-2. src/trend_analyzer.py (ì¶”ì„¸ ì¶”ì¢…)
python
# src/trend_analyzer.py
import pandas as pd
from src.logger import app_logger

class TrendFollowingAnalyzer:
    """
    ì¶”ì„¸ ì¶”ì¢… (Trend Following)
    RSI + EMA ì´ì¤‘í™•ì¸
    """
    
    def __init__(self, rsi_period=14, ema_fast=12, ema_slow=26):
        self.rsi_period = rsi_period
        self.ema_fast = ema_fast
        self.ema_slow = ema_slow
    
    def calculate_rsi(self, df, period=14):
        """RSI ê³„ì‚°"""
        delta = df['close'].diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
        rs = gain / loss
        rsi = 100 - (100 / (1 + rs))
        return rsi
    
    def calculate_ema(self, df, period):
        """EMA ê³„ì‚°"""
        return df['close'].ewm(span=period, adjust=False).mean()
    
    def analyze(self, df):
        """
        ì¶”ì„¸ ë¶„ì„
        """
        if len(df) < max(self.rsi_period, self.ema_slow) + 5:
            return {"action": "HOLD", "reason": "Insufficient data"}
        
        # RSI ê³„ì‚°
        df['rsi'] = self.calculate_rsi(df, self.rsi_period)
        
        # EMA ê³„ì‚°
        df['ema_fast'] = self.calculate_ema(df, self.ema_fast)
        df['ema_slow'] = self.calculate_ema(df, self.ema_slow)
        
        current_price = df['close'].iloc[-1]
        current_rsi = df['rsi'].iloc[-1]
        ema_fast = df['ema_fast'].iloc[-1]
        ema_slow = df['ema_slow'].iloc[-1]
        
        # ê³¨ë“ í¬ë¡œìŠ¤ (EMA Fast > Slow) + ì €RSI
        if ema_fast > ema_slow and current_rsi < 50:
            return {
                "action": "BUY",
                "reason": "Golden Cross + RSI < 50",
                "entry_price": current_price,
                "rsi": current_rsi,
                "confidence": 80
            }
        
        # ë°ë“œí¬ë¡œìŠ¤ (EMA Fast < Slow) + ê³ RSI
        if ema_fast < ema_slow and current_rsi > 50:
            return {
                "action": "SELL",
                "reason": "Dead Cross + RSI > 50",
                "entry_price": current_price,
                "rsi": current_rsi,
                "confidence": 80
            }
        
        return {
            "action": "HOLD",
            "reason": "No clear trend signal",
            "rsi": current_rsi
        }
ì´ì œ í¬ì§€ì…˜ ê´€ë¦¬ì, ìœ„í—˜ ê´€ë¦¬, í†µí•© ë´‡ì„ ì°¨ê·¼ì°¨ê·¼ êµ¬í˜„í•˜ê² ìŠµë‹ˆë‹¤.

ê³„ì†í•˜ì‹œê² ìŠµë‹ˆê¹Œ? ì•„ë‹ˆë©´ ì§€ê¸ˆê¹Œì§€ ì½”ë“œë¥¼ ê²€í† í•˜ê³  ì‹¶ìœ¼ì‹ ê°€ìš”?

ê³„ì† ì½”ë”© ì‹¤í–‰í•´ì¤˜.
ê³„ì† ì§„í–‰í•˜ê² ìŠµë‹ˆë‹¤. í¬ì§€ì…˜ ê´€ë¦¬, ìœ„í—˜ ê´€ë¦¬, í†µí•© ë´‡ì„ êµ¬í˜„í•©ë‹ˆë‹¤.

ğŸ’¼ Step 5: í¬ì§€ì…˜ ê´€ë¦¬ì
5-1. src/position_manager.py
python
# src/position_manager.py
from datetime import datetime
from src.logger import app_logger

class Position:
    """
    ê°œë³„ í¬ì§€ì…˜ ê°ì²´
    """
    
    def __init__(self, symbol, entry_price, strategy, size, target_profit, stop_loss):
        self.symbol = symbol
        self.entry_price = entry_price
        self.strategy = strategy  # "ICT" or "TREND"
        self.size = size
        self.target_profit = target_profit
        self.stop_loss = stop_loss
        self.entry_time = datetime.now()
        self.entry_uuid = None  # ì£¼ë¬¸ UUID
    
    def get_pnl_percent(self, current_price):
        """í˜„ì¬ ì†ìµë¥  ê³„ì‚°"""
        return (current_price - self.entry_price) / self.entry_price * 100
    
    def should_take_profit(self, current_price):
        """ìµì ˆ ì²´í¬"""
        return self.get_pnl_percent(current_price) >= self.target_profit
    
    def should_stop_loss(self, current_price):
        """ì†ì ˆ ì²´í¬"""
        return self.get_pnl_percent(current_price) <= -self.stop_loss
    
    def should_timeout(self, timeout_seconds):
        """íƒ€ì„ì•„ì›ƒ ì²´í¬"""
        elapsed = (datetime.now() - self.entry_time).total_seconds()
        return elapsed > timeout_seconds

class PositionManager:
    """
    í¬ì§€ì…˜ ìƒëª…ì£¼ê¸° ê´€ë¦¬
    ì§„ì… â†’ ë³´ìœ  â†’ ì²­ì‚°
    """
    
    def __init__(self, upbit_client):
        self.upbit = upbit_client
        self.positions = {}  # symbol -> Position
        self.closed_positions = []  # ì²­ì‚° ê¸°ë¡
        self.daily_pnl = 0.0
    
    def open_position(self, symbol, entry_price, strategy, size, target_profit, stop_loss):
        """
        í¬ì§€ì…˜ ì§„ì…
        """
        if symbol in self.positions:
            app_logger.warning(f"Position already exists for {symbol}")
            return False
        
        position = Position(
            symbol=symbol,
            entry_price=entry_price,
            strategy=strategy,
            size=size,
            target_profit=target_profit,
            stop_loss=stop_loss
        )
        
        self.positions[symbol] = position
        app_logger.info(
            f"[OPEN] {strategy} {symbol} @ {entry_price} "
            f"| Size: {size} | TP: {target_profit}% | SL: {stop_loss}%"
        )
        return True
    
    def close_position(self, symbol, current_price, reason):
        """
        í¬ì§€ì…˜ ì²­ì‚°
        """
        if symbol not in self.positions:
            return False
        
        position = self.positions[symbol]
        pnl_percent = position.get_pnl_percent(current_price)
        realized_pnl = (current_price - position.entry_price) * position.size
        
        self.daily_pnl += pnl_percent
        
        closed_record = {
            "symbol": symbol,
            "strategy": position.strategy,
            "entry_price": position.entry_price,
            "exit_price": current_price,
            "size": position.size,
            "pnl_percent": pnl_percent,
            "pnl_krw": realized_pnl,
            "entry_time": position.entry_time,
            "exit_time": datetime.now(),
            "duration_seconds": (datetime.now() - position.entry_time).total_seconds(),
            "reason": reason
        }
        
        self.closed_positions.append(closed_record)
        del self.positions[symbol]
        
        app_logger.info(
            f"[CLOSE] {symbol} @ {current_price} | {reason} | "
            f"PnL: {pnl_percent:.2f}% ({realized_pnl:.0f} KRW) | "
            f"Duration: {closed_record['duration_seconds']:.0f}s"
        )
        
        return True
    
    def update_all_positions(self, current_prices):
        """
        ëª¨ë“  í¬ì§€ì…˜ ì—…ë°ì´íŠ¸
        10ì´ˆë§ˆë‹¤ í˜¸ì¶œ
        """
        closed_symbols = []
        
        for symbol, position in list(self.positions.items()):
            if symbol not in current_prices:
                continue
            
            current_price = current_prices[symbol]
            pnl = position.get_pnl_percent(current_price)
            
            # ìµì ˆ
            if position.should_take_profit(current_price):
                self.close_position(symbol, current_price, "TAKE_PROFIT")
                closed_symbols.append(symbol)
            
            # ì†ì ˆ
            elif position.should_stop_loss(current_price):
                self.close_position(symbol, current_price, "STOP_LOSS")
                closed_symbols.append(symbol)
            
            # íƒ€ì„ì•„ì›ƒ (ì¶”ì„¸ ì¶”ì¢…ë§Œ)
            elif position.strategy == "TREND" and position.should_timeout(300):
                self.close_position(symbol, current_price, "TIMEOUT")
                closed_symbols.append(symbol)
        
        return closed_symbols
    
    def get_open_positions(self):
        """ì—´ë¦° í¬ì§€ì…˜ ë°˜í™˜"""
        return self.positions
    
    def get_position_count(self):
        """ì—´ë¦° í¬ì§€ì…˜ ê°œìˆ˜"""
        return len(self.positions)
    
    def get_daily_pnl(self):
        """ì¼ì¼ ì†ìµ"""
        return self.daily_pnl
    
    def reset_daily(self):
        """ì¼ì¼ ë¦¬ì…‹"""
        self.daily_pnl = 0.0
        self.closed_positions = []
        app_logger.info("Daily metrics reset")
    
    def get_statistics(self):
        """í†µê³„"""
        if not self.closed_positions:
            return {
                "total_trades": 0,
                "win_count": 0,
                "loss_count": 0,
                "win_rate": 0,
                "avg_win": 0,
                "avg_loss": 0,
                "total_pnl": 0
            }
        
        wins = [p["pnl_percent"] for p in self.closed_positions if p["pnl_percent"] > 0]
        losses = [p["pnl_percent"] for p in self.closed_positions if p["pnl_percent"] < 0]
        
        return {
            "total_trades": len(self.closed_positions),
            "win_count": len(wins),
            "loss_count": len(losses),
            "win_rate": (len(wins) / len(self.closed_positions) * 100) if self.closed_positions else 0,
            "avg_win": sum(wins) / len(wins) if wins else 0,
            "avg_loss": sum(losses) / len(losses) if losses else 0,
            "total_pnl": sum(p["pnl_percent"] for p in self.closed_positions)
        }
ğŸ›¡ï¸ Step 6: ìœ„í—˜ ê´€ë¦¬
6-1. src/risk_control.py
python
# src/risk_control.py
from datetime import datetime
from src.logger import app_logger
from config import Config

class RiskControl:
    """
    ì¼ì¼ ìœ„í—˜ ê´€ë¦¬
    ëª©í‘œ ë‹¬ì„± í›„ ì „ëµ ì¡°ì •
    ìµœëŒ€ ì†ì‹¤ ì œí•œ
    """
    
    def __init__(self):
        self.daily_target = Config.RISK_CONFIG["daily_target_percent"]
        self.max_daily_loss = Config.RISK_CONFIG["max_daily_loss_percent"]
        self.max_daily_trades = Config.RISK_CONFIG["max_daily_trades"]
        
        self.reset_daily()
    
    def reset_daily(self):
        """ì¼ì¼ ë¦¬ì…‹ (ìì •)"""
        self.daily_pnl = 0.0
        self.trade_count = 0
        self.last_reset = datetime.now()
        app_logger.info("Daily risk control reset")
    
    def should_reset_daily(self):
        """ìì •ì´ ì§€ë‚¬ëŠ”ê°€?"""
        now = datetime.now()
        if now.day != self.last_reset.day:
            return True
        return False
    
    def add_trade(self):
        """ê±°ë˜ ì¹´ìš´íŠ¸ ì¦ê°€"""
        self.trade_count += 1
    
    def update_pnl(self, pnl_percent):
        """ì†ìµ ì—…ë°ì´íŠ¸"""
        self.daily_pnl += pnl_percent
    
    def get_status(self):
        """
        í˜„ì¬ ìƒíƒœ ë°˜í™˜
        """
        if self.daily_pnl >= self.daily_target:
            return "TARGET_ACHIEVED"
        elif self.daily_pnl <= -self.max_daily_loss:
            return "MAX_LOSS_HIT"
        elif self.trade_count >= self.max_daily_trades:
            return "MAX_TRADES_HIT"
        else:
            return "RUNNING"
    
    def can_trade(self):
        """ê±°ë˜ ê°€ëŠ¥ ì—¬ë¶€"""
        status = self.get_status()
        return status == "RUNNING" or status == "TARGET_ACHIEVED"
    
    def should_use_ict(self):
        """ICT ì „ëµ ì‚¬ìš© ì—¬ë¶€"""
        status = self.get_status()
        
        # ëª©í‘œ ë‹¬ì„± í›„: ICT ë¹„í™œì„±í™” (ì¶”ì„¸ë§Œ)
        if status == "TARGET_ACHIEVED":
            return False
        # ìµœëŒ€ ì†ì‹¤/ê±°ë˜ ë„ë‹¬: ëª¨ë‘ ë¹„í™œì„±í™”
        elif status in ["MAX_LOSS_HIT", "MAX_TRADES_HIT"]:
            return False
        # ì •ìƒ: ëª¨ë‘ í™œì„±í™”
        else:
            return True
    
    def should_use_trend(self):
        """ì¶”ì„¸ ì „ëµ ì‚¬ìš© ì—¬ë¶€"""
        status = self.get_status()
        
        # ìµœëŒ€ ì†ì‹¤/ê±°ë˜ ë„ë‹¬: ë¹„í™œì„±í™”
        if status in ["MAX_LOSS_HIT", "MAX_TRADES_HIT"]:
            return False
        # ë‚˜ë¨¸ì§€: í™œì„±í™”
        else:
            return True
    
    def get_position_size_multiplier(self):
        """
        í¬ì§€ì…˜ í¬ê¸° ë°°ìˆ˜
        ëª©í‘œ ë‹¬ì„± í›„ ì¶•ì†Œ
        """
        if self.daily_pnl >= self.daily_target:
            return 0.5  # 50% ì¶•ì†Œ
        elif self.daily_pnl >= self.daily_target * 0.5:
            return 0.75  # 25% ì¶•ì†Œ
        else:
            return 1.0  # ì •ìƒ
    
    def log_status(self):
        """ìƒíƒœ ë¡œê¹…"""
        status = self.get_status()
        app_logger.info(
            f"Daily Risk | PnL: {self.daily_pnl:.2f}% "
            f"| Trades: {self.trade_count}/{self.max_daily_trades} "
            f"| Status: {status}"
        )
ğŸ¤– Step 7: í†µí•© ë´‡ ì—”ì§„
7-1. src/hybrid_bot.py (ë©”ì¸ ë´‡ ë¡œì§)
python
# src/hybrid_bot.py
import time
from datetime import datetime
import pandas as pd
from config import Config
from src.logger import app_logger
from src.upbit_client import UpbitClient
from src.ict_analyzer import ICTAnalyzer
from src.trend_analyzer import TrendFollowingAnalyzer
from src.position_manager import PositionManager
from src.risk_control import RiskControl

class HybridTradingBot:
    """
    ICT + Trend Following í•˜ì´ë¸Œë¦¬ë“œ ë´‡
    ëª©í‘œ: ë§¤ì¼ 1% ìˆ˜ìµë¥ 
    """
    
    def __init__(self):
        self.upbit = UpbitClient()
        self.ict = ICTAnalyzer(min_confluence=Config.ICT_CONFIG["min_confluence"])
        self.trend = TrendFollowingAnalyzer()
        self.position_mgr = PositionManager(self.upbit)
        self.risk_ctrl = RiskControl()
        
        self.symbols = Config.SYMBOLS
        self.running = False
        
        app_logger.info(f"Bot initialized with symbols: {self.symbols}")
    
    # ===== ICT ê±°ë˜ =====
    def execute_ict_trade(self, symbol):
        """
        ICT ê¸°ë°˜ ê³ ìŠ¹ë¥  ê±°ë˜
        í•˜ë£¨ 1~2íšŒ ì •ë„ ì‹ í˜¸
        """
        try:
            # 1. 1ì‹œê°„ ìº”ë“¤ ì¡°íšŒ
            df = self.upbit.get_candles(
                symbol,
                interval=Config.ICT_CONFIG["timeframe"],
                count=50
            )
            
            # 2. ICT ë¶„ì„
            signal = self.ict.analyze(df)
            
            if not signal["ready"]:
                return False
            
            if signal["confidence"] < Config.ICT_CONFIG["min_confidence"]:
                app_logger.debug(f"[{symbol}] ICT confidence too low: {signal['confidence']:.0f}%")
                return False
            
            # 3. ì§„ì… ì¤€ë¹„
            ob = signal["order_block"]
            if not ob.get("found"):
                return False
            
            # 4. í˜¸ê°€ ì¡°íšŒ
            orderbook = self.upbit.get_orderbook(symbol)
            bid_price = orderbook['orderbook_units'][0]['bid_price']
            
            # 5. ê°­ ì²´í¬ (í˜¸ê°€ ìŠ¤í”„ë ˆë“œ)
            ask_price = orderbook['orderbook_units'][0]['ask_price']
            gap_percent = (ask_price - bid_price) / bid_price * 100
            
            if gap_percent > 0.5:
                app_logger.debug(f"[{symbol}] Gap too high: {gap_percent:.3f}%")
                return False
            
            # 6. í¬ì§€ì…˜ í¬ê¸° ê³„ì‚°
            portfolio_value = self._get_portfolio_value()
            position_size = portfolio_value * Config.ICT_CONFIG["position_size_ratio"]
            position_size *= self.risk_ctrl.get_position_size_multiplier()
            
            # 7. ì§„ì…
            self.position_mgr.open_position(
                symbol=symbol,
                entry_price=bid_price,
                strategy="ICT",
                size=position_size,
                target_profit=Config.ICT_CONFIG["take_profit_percent"],
                stop_loss=Config.ICT_CONFIG["stop_loss_percent"]
            )
            
            self.risk_ctrl.add_trade()
            
            app_logger.info(
                f"[ICT ENTRY] {symbol} @ {bid_price} | "
                f"Size: {position_size:.0f} | Confluence: {signal['confluence']}/3"
            )
            
            return True
        
        except Exception as e:
            app_logger.error(f"ICT trade error for {symbol}: {str(e)}")
            return False
    
    # ===== ì¶”ì„¸ ì¶”ì¢… ê±°ë˜ =====
    def execute_trend_trade(self, symbol):
        """
        ì¶”ì„¸ ì¶”ì¢… ìŠ¤ìº˜í•‘
        5ë¶„ë´‰ ê³ ë¹ˆë„ ê±°ë˜
        """
        try:
            # 1. 5ë¶„ ìº”ë“¤ ì¡°íšŒ
            df = self.upbit.get_candles(
                symbol,
                interval=Config.TREND_CONFIG["timeframe"],
                count=30
            )
            
            # 2. ì¶”ì„¸ ë¶„ì„
            signal = self.trend.analyze(df)
            
            if signal["action"] == "HOLD":
                return False
            
            # 3. í˜¸ê°€ ì¡°íšŒ
            orderbook = self.upbit.get_orderbook(symbol)
            
            if signal["action"] == "BUY":
                price = orderbook['orderbook_units'][0]['bid_price']
            else:  # SELL
                price = orderbook['orderbook_units'][0]['ask_price']
            
            # 4. ê°­ ì²´í¬
            bid = orderbook['orderbook_units'][0]['bid_price']
            ask = orderbook['orderbook_units'][0]['ask_price']
            gap = (ask - bid) / bid * 100
            
            if gap > 0.5:
                return False
            
            # 5. í¬ì§€ì…˜ í¬ê¸° (ì¶”ì„¸ëŠ” ë” ì‘ìŒ)
            portfolio_value = self._get_portfolio_value()
            position_size = portfolio_value * Config.TREND_CONFIG["position_size_ratio"]
            position_size *= self.risk_ctrl.get_position_size_multiplier()
            
            # 6. ì§„ì…
            self.position_mgr.open_position(
                symbol=symbol,
                entry_price=price,
                strategy="TREND",
                size=position_size,
                target_profit=Config.TREND_CONFIG["take_profit_percent"],
                stop_loss=Config.TREND_CONFIG["stop_loss_percent"]
            )
            
            self.risk_ctrl.add_trade()
            
            app_logger.debug(
                f"[TREND] {signal['action']} {symbol} @ {price} | RSI: {signal.get('rsi', 'N/A'):.1f}"
            )
            
            return True
        
        except Exception as e:
            app_logger.error(f"Trend trade error for {symbol}: {str(e)}")
            return False
    
    # ===== í¬ì§€ì…˜ ì—…ë°ì´íŠ¸ =====
    def update_positions(self):
        """
        ì—´ë¦° í¬ì§€ì…˜ ê°€ê²© ì—…ë°ì´íŠ¸
        10ì´ˆë§ˆë‹¤ í˜¸ì¶œ
        """
        try:
            current_prices = {}
            
            for symbol in self.symbols:
                try:
                    df = self.upbit.get_candles(symbol, interval="1m", count=1)
                    current_prices[symbol] = df['close'].iloc[-1]
                except:
                    continue
            
            # í¬ì§€ì…˜ ì—…ë°ì´íŠ¸
            closed = self.position_mgr.update_all_positions(current_prices)
            
            for symbol in closed:
                self.risk_ctrl.add_trade()
        
        except Exception as e:
            app_logger.error(f"Position update error: {str(e)}")
    
    # ===== ì¼ì¼ ë£¨í‹´ =====
    def morning_routine(self):
        """
        09:00 ì•„ì¹¨ ë£¨í‹´
        ICT ì‹ í˜¸ ìŠ¤ìº” (ì¼ 1íšŒ)
        """
        if not self.risk_ctrl.should_use_ict():
            app_logger.debug("ICT disabled by risk control")
            return
        
        for symbol in self.symbols:
            try:
                self.execute_ict_trade(symbol)
                time.sleep(2)  # API ë ˆì´íŠ¸ ë¦¬ë°‹
            except Exception as e:
                app_logger.error(f"Morning routine error for {symbol}: {str(e)}")
    
    def intraday_routine(self):
        """
        10ë¶„ë§ˆë‹¤ ì‹¤í–‰
        ì¶”ì„¸ ì¶”ì¢… ì‹ í˜¸ ìŠ¤ìº”
        í¬ì§€ì…˜ ì—…ë°ì´íŠ¸
        """
        if not self.risk_ctrl.can_trade():
            app_logger.warning(f"Trading disabled. Status: {self.risk_ctrl.get_status()}")
            return
        
        # í¬ì§€ì…˜ ì—…ë°ì´íŠ¸ (ê°€ì¥ ì¤‘ìš”)
        self.update_positions()
        
        # ìœ„í—˜ ê´€ë¦¬ ì²´í¬
        if not self.risk_ctrl.should_use_trend():
            return
        
        # ì¶”ì„¸ ê±°ë˜
        for symbol in self.symbols:
            try:
                self.execute_trend_trade(symbol)
                time.sleep(1)  # API ë ˆì´íŠ¸ ë¦¬ë°‹
            except Exception as e:
                app_logger.error(f"Intraday routine error for {symbol}: {str(e)}")
        
        # ë¡œê¹…
        self.risk_ctrl.log_status()
    
    # ===== ìœ í‹¸ë¦¬í‹° =====
    def _get_portfolio_value(self):
        """í¬íŠ¸í´ë¦¬ì˜¤ ê°€ì¹˜ ê³„ì‚°"""
        try:
            balance = self.upbit.get_balance("KRW")
            return balance or Config.INITIAL_CAPITAL
        except:
            return Config.INITIAL_CAPITAL
    
    def log_summary(self):
        """ì¼ì¼ ìš”ì•½"""
        stats = self.position_mgr.get_statistics()
        app_logger.info(
            f"Daily Summary | Trades: {stats['total_trades']} | "
            f"Win Rate: {stats['win_rate']:.1f}% | "
            f"Total PnL: {stats['total_pnl']:.2f}%"
        )
    
    # ===== ë©”ì¸ ë£¨í”„ =====
    def run(self):
        """
        ë©”ì¸ ì‹¤í–‰ ë£¨í”„
        """
        app_logger.info("Starting hybrid bot...")
        self.running = True
        
        last_morning = None
        last_reset = None
        
        try:
            while self.running:
                now = datetime.now()
                
                # ìì • ë¦¬ì…‹
                if self.risk_ctrl.should_reset_daily():
                    self.position_mgr.reset_daily()
                    self.risk_ctrl.reset_daily()
                    self.log_summary()
                
                # 09:00 ì•„ì¹¨ ë£¨í‹´
                if now.hour == 9 and last_morning != now.day:
                    self.morning_routine()
                    last_morning = now.day
                
                # 10ë¶„ë§ˆë‹¤ ì¸íŠ¸ë¼ë°ì´ ë£¨í‹´
                if now.minute % 10 == 0 and last_reset != now.minute:
                    self.intraday_routine()
                    last_reset = now.minute
                
                time.sleep(10)
        
        except KeyboardInterrupt:
            app_logger.info("Bot stopped by user")
        except Exception as e:
            app_logger.error(f"Bot error: {str(e)}")
        finally:
            self.running = False
            self.log_summary()
            app_logger.info("Bot shutdown")
    
    def stop(self):
        """ë´‡ ì¤‘ì§€"""
        self.running = False
        app_logger.info("Stop signal sent to bot")
ğŸš€ Step 8: ë©”ì¸ ì§„ì…ì 
8-1. main.py
python
# main.py
import os
import logging
from config import get_config
from src.logger import setup_logger, app_logger
from src.hybrid_bot import HybridTradingBot

# ë¡œê¹… ì„¤ì •
config = get_config()
setup_logger("hybrid-bot")

def main():
    """
    ë©”ì¸ ì§„ì…ì 
    Railway í™˜ê²½ì—ì„œ ì‹¤í–‰
    """
    
    app_logger.info(f"Environment: {config.ENVIRONMENT}")
    app_logger.info(f"Debug: {config.DEBUG}")
    app_logger.info(f"Symbols: {config.SYMBOLS}")
    
    # ë´‡ ìƒì„± ë° ì‹¤í–‰
    bot = HybridTradingBot()
    
    try:
        bot.run()
    except Exception as e:
        app_logger.error(f"Fatal error: {str(e)}")
        raise

if __name__ == "__main__":
    main()
ğŸ“¦ Step 9: ë°°í¬ ì„¤ì •
9-1. Procfile (Railway)
text
web: gunicorn --bind 0.0.0.0:8000 app:app
worker: python main.py
9-2. railway.json
json
{
  "services": [
    {
      "name": "hybrid-trading-bot",
      "image": "python:3.11",
      "command": "python main.py",
      "variables": {
        "ENVIRONMENT": "production"
      }
    }
  ]
}
9-3. .github/workflows/deploy.yml
text
name: Deploy to Railway

on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Install Railway CLI
        run: npm i -g @railway/cli
      
      - name: Deploy to Railway
        env:
          RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}
        run: railway up --detach
ğŸ§ª Step 10: í…ŒìŠ¤íŠ¸
10-1. tests/test_ict_analyzer.py
python
# tests/test_ict_analyzer.py
import pandas as pd
from src.ict_analyzer import ICTAnalyzer

def test_order_block_detection():
    """Order Block ê°ì§€ í…ŒìŠ¤íŠ¸"""
    
    # í…ŒìŠ¤íŠ¸ ë°ì´í„° ìƒì„± (ìƒìŠ¹ íŒ¨í„´)
    data = {
        'open': [100, 102, 104, 106, 108],
        'high': [101, 103, 105, 107, 109],
        'low': [99, 101, 103, 105, 107],
        'close': [102, 104, 106, 108, 110],
        'volume': [1000] * 5
    }
    df = pd.DataFrame(data)
    
    ict = ICTAnalyzer()
    result = ict.detect_order_block(df)
    
    assert result["found"] == True
    assert result["type"] == "bullish_ob"
    print("âœ… Order Block test passed")

def test_confluence():
    """Confluence í…ŒìŠ¤íŠ¸"""
    
    data = {
        'open': [100, 102, 104, 101, 103],
        'high': [105, 107, 109, 106, 108],
        'low': [99, 101, 103, 100, 102],
        'close': [102, 104, 106, 105, 107],
        'volume': [1000] * 5
    }
    df = pd.DataFrame(data)
    
    ict = ICTAnalyzer(min_confluence=2)
    result = ict.analyze(df)
    
    print(f"Confluence: {result['confluence']}/3")
    print("âœ… Confluence test passed")

if __name__ == "__main__":
    test_order_block_detection()
    test_confluence()
10-2. tests/test_trend_analyzer.py
python
# tests/test_trend_analyzer.py
import pandas as pd
from src.trend_analyzer import TrendFollowingAnalyzer

def test_rsi_calculation():
    """RSI ê³„ì‚° í…ŒìŠ¤íŠ¸"""
    
    # ìƒìŠ¹ ì¶”ì„¸ ë°ì´í„°
    data = {
        'open': list(range(100, 120)),
        'high': list(range(101, 121)),
        'low': list(range(99, 119)),
        'close': list(range(100, 120)),
        'volume': [1000] * 20
    }
    df = pd.DataFrame(data)
    
    trend = TrendFollowingAnalyzer()
    df['rsi'] = trend.calculate_rsi(df, 14)
    
    print(f"RSI values: {df['rsi'].tail()}")
    print("âœ… RSI calculation test passed")

def test_trend_signal():
    """ì¶”ì„¸ ì‹ í˜¸ í…ŒìŠ¤íŠ¸"""
    
    data = {
        'open': list(range(100, 120)),
        'high': list(range(101, 121)),
        'low': list(range(99, 119)),
        'close': list(range(100, 120)),
        'volume': [1000] * 20
    }
    df = pd.DataFrame(data)
    
    trend = TrendFollowingAnalyzer()
    signal = trend.analyze(df)
    
    print(f"Signal: {signal['action']}")
    print("âœ… Trend signal test passed")

if __name__ == "__main__":
    test_rsi_calculation()
    test_trend_signal()
ğŸ“ Step 11: .gitignore
text
# .gitignore
.env
.env.local
__pycache__/
*.pyc
*.pyo
*.pyd
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# IDE
.vscode/
.idea/
*.swp
*.swo

# Logs
logs/
*.log

# Bot specific
.DS_Store
data/
cache/
ğŸ“– Step 12: README.md
text
# Hybrid Trading Bot (ICT + Trend Following)

ìë™ ë§¤ë§¤ ë´‡ìœ¼ë¡œ ë§¤ì¼ 1% ìˆ˜ìµë¥  ë‹¬ì„±ì„ ëª©í‘œí•©ë‹ˆë‹¤.

## íŠ¹ì§•

- **ICT (Smart Money)**: ê³ ìŠ¹ë¥  ë‹¨íƒ€ (70~75% ìŠ¹ë¥ )
- **ì¶”ì„¸ ì¶”ì¢…**: ê³ ë¹ˆë„ ê±°ë˜ (20~30íšŒ/ì¼)
- **ìœ„í—˜ ê´€ë¦¬**: ì¼ì¼ ëª©í‘œ ë‹¬ì„± í›„ ìë™ ì¶•ì†Œ
- **ì—…ë¹„íŠ¸ API**: ë ˆì´íŠ¸ ë¦¬ë°‹ ì¤€ìˆ˜, ìºì‹± ì ìš©

## ì„¤ì¹˜

```bash
git clone <repo>
cd hybrid-trading-bot
pip install -r requirements.txt
cp .env.example .env
# .env íŒŒì¼ì— API í‚¤ ì…ë ¥
ì‹¤í–‰
bash
# ê°œë°œ ëª¨ë“œ
python main.py

# í”„ë¡œë•ì…˜ ëª¨ë“œ (Railway)
ENVIRONMENT=production python main.py
ë°°í¬
bash
# Railway ë°°í¬
railway up
ì„¤ì •
config.pyì—ì„œ ë‹¤ìŒì„ ìˆ˜ì •:

SYMBOLS: ê±°ë˜í•  ì¢…ëª©

INITIAL_CAPITAL: ì´ˆê¸° ìë³¸

ICT_CONFIG: ICT íŒŒë¼ë¯¸í„°

TREND_CONFIG: ì¶”ì„¸ íŒŒë¼ë¯¸í„°

RISK_CONFIG: ìœ„í—˜ ê´€ë¦¬

ì£¼ì˜ì‚¬í•­
âš ï¸ í•­ìƒ ì†ŒëŸ‰ìœ¼ë¡œ í…ŒìŠ¤íŠ¸í•˜ì„¸ìš”
âš ï¸ í”„ë¡œë•ì…˜ ë°°í¬ ì „ ë°ëª¨ ê±°ë˜ 1ì£¼ì¼ í•„ìˆ˜
âš ï¸ API ë ˆì´íŠ¸ ë¦¬ë°‹ ì¤€ìˆ˜

ë¼ì´ì„ ìŠ¤
MIT

text

***

ì´ì œ **ì™„ì „í•œ í”„ë¡œë•ì…˜ ë ˆë²¨ ì½”ë“œ**ê°€ ì™„ì„±ë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¤ìŒ ë‹¨ê³„ëŠ”?

âœ… ì½”ë“œ êµ¬ì¡° ì„¤ê³„ ì™„ë£Œ

âœ… ëª¨ë“  ëª¨ë“ˆ êµ¬í˜„ ì™„ë£Œ

ğŸ”„ ë¡œì»¬ í…ŒìŠ¤íŠ¸ (ë‹¤ìŒ ë‹¨ê³„)

ğŸ”„ ë°ëª¨ ê±°ë˜ 1ì£¼ì¼

ğŸ”„ Railway ë°°í¬

text

**ë¡œì»¬ì—ì„œ í…ŒìŠ¤íŠ¸í•˜ë ¤ë©´:**

```bash
# 1. í™˜ê²½ ì„¤ì •
python -m venv venv
source venv/bin/activate  # Windows: venv\Scripts\activate
pip install -r requirements.txt

# 2. í…ŒìŠ¤íŠ¸ ì‹¤í–‰
python -m pytest tests/

# 3. ë´‡ ì‹¤í–‰ (API í‚¤ ì„¤ì • í›„)
python main.py
ì¶”ê°€ ì§ˆë¬¸ ìˆìœ¼ì‹ ê°€ìš”?